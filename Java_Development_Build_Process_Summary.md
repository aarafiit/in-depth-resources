
# Complete Java Development & Build Process — Detailed Learning Resource

---

## 1. Understanding Compilation, Interpretation, and Execution

| Term         | Definition                                                                                   | Example                          |
|--------------|----------------------------------------------------------------------------------------------|---------------------------------|
| **Compiler** | Translates source code (high-level) into lower-level code.                                  | `javac Hello.java` produces `.class` files |
| **Interpreter** | Executes code line-by-line or interprets intermediate code at runtime.                     | JVM interprets Java bytecode     |
| **JVM**      | Java Virtual Machine, platform-specific interpreter that runs Java bytecode.                 | Runs `.class` files anywhere JVM exists |
| **JRE**      | Java Runtime Environment; JVM + core libraries to run Java programs.                        | Needed to run Java applications  |
| **JDK**      | Java Development Kit; JRE + development tools like compiler (`javac`), debugger, etc.       | Needed to write and compile Java programs |

### Why Java Compiles + Interprets?

- Java source → compiled to **bytecode** (platform-independent).
- Bytecode runs on JVM, which interprets or JIT-compiles it to machine code specific to your OS/CPU.
- This enables **Write Once, Run Anywhere**.

---

### **Hands-on exercise 1**

1. Write a simple Java program `Hello.java`:

    ```java
    public class Hello {
        public static void main(String[] args) {
            System.out.println("Hello from Java!");
        }
    }
    ```

2. Compile with:
    ```bash
    javac Hello.java
    ```
    → Generates `Hello.class` (bytecode)

3. Run with:
    ```bash
    java Hello
    ```

---

## 2. Java vs C/C++ Portability Explained

| Feature             | Java                                        | C/C++                                      |
|---------------------|---------------------------------------------|--------------------------------------------|
| Compilation Output  | Bytecode (`.class`) - platform independent | Native machine code - platform dependent   |
| Execution          | JVM interprets bytecode at runtime           | OS executes machine code directly           |
| Portability        | Portable across platforms with JVM           | Must recompile for each OS/architecture     |

### Example: Portability Test

- Compile Java code once → run `.class` on Windows, Linux, macOS without changes.
- Compile C/C++ code on Linux → try running executable on Windows → fails.

---

### Hands-on exercise 2

1. Create C program `hello.c`:

    ```c
    #include <stdio.h>
    int main() {
        printf("Hello from C!\n");
        return 0;
    }
    ```

2. Compile on Linux:
    ```bash
    gcc hello.c -o hello
    ./hello  # Works
    ```

3. Copy `hello` binary to Windows → won’t run.

4. Recompile on Windows with `gcc` or Visual Studio → executable runs there.

---

## 3. Bytecode vs Machine Code

| Aspect            | Bytecode                          | Machine Code                    |
|-------------------|----------------------------------|--------------------------------|
| What it is        | Intermediate platform-independent code | Native binary code specific to CPU/OS |
| Generated by      | Java compiler (`javac`)           | C/C++ compiler (`gcc`, `clang`) |
| Executed by       | JVM (interprets or JIT compiles) | CPU directly                   |
| Portability       | Runs anywhere JVM exists          | Platform-specific              |
| Performance       | Slightly slower initially, improved by JIT | Fast native execution          |

---

## 4. Java Compilation Outputs: `.class` and `.jar`

| Output     | What it is                               | How it’s generated                   | Usage                                    |
|------------|------------------------------------------|------------------------------------|------------------------------------------|
| `.class`   | Single compiled bytecode class file      | `javac Hello.java`                  | Run with `java Hello`                     |
| `.jar`     | Java archive (ZIP of many `.class` files + metadata) | `jar cvf MyApp.jar *.class` or build tools (Gradle/Maven/IDE) | Run with `java -jar MyApp.jar`            |

### Manifest & Executable JAR

- The `META-INF/MANIFEST.MF` inside a JAR specifies `Main-Class`.
- Without this, `java -jar` shows error: **no main manifest attribute**.
- Manifest example:
  ```
  Manifest-Version: 1.0
  Main-Class: com.example.Main
  ```

---

### Hands-on exercise 3: Creating a JAR

1. Compile Java files:
    ```bash
    javac -d out Hello.java
    ```

2. Create `manifest.txt` with:
    ```
    Main-Class: Hello
    ```

3. Create JAR:
    ```bash
    jar cfm Hello.jar manifest.txt -C out/ .
    ```

4. Run JAR:
    ```bash
    java -jar Hello.jar
    ```

---

## 5. Java Build Process in IntelliJ IDEA

- IntelliJ compiles `.java` → `.class` into an **output folder** (default: `out/production/<project>`).
- `.class` files are hidden from source directories to keep workspace clean.
- You can create a **JAR artifact** in IntelliJ:
  - Go to `File → Project Structure → Artifacts`.
  - Add JAR artifact specifying your main class.
  - Build artifact from `Build → Build Artifacts`.
- Resulting `.jar` appears in `out/artifacts/<artifact-name>/`.

---

## 6. The `META-INF` Folder in JARs

- Contains **manifest file** (`MANIFEST.MF`) and optionally signatures.
- Manifest file directs JVM on how to run the JAR.
- JVM looks here for `Main-Class` to find entry point.

### Explore JAR contents

```bash
jar tf MyApp.jar
jar xf MyApp.jar META-INF/MANIFEST.MF
cat META-INF/MANIFEST.MF
```

---

## 7. Gradle and Gradle Wrapper (`gradlew`)

| Term           | Description                                               |
|----------------|-----------------------------------------------------------|
| Gradle         | Build automation tool for Java projects                   |
| `gradlew`      | Gradle Wrapper shell script; auto-downloads required Gradle version |
| `gradlew.bat`  | Windows batch script equivalent of `gradlew`              |

### Benefits of Gradle Wrapper

- No need to install Gradle globally.
- Ensures everyone uses same Gradle version.
- Easier CI integration.

---

### Hands-on exercise 4: Using Gradle Wrapper

1. Make wrapper executable:

    ```bash
    chmod +x gradlew
    ```

2. Build project:

    ```bash
    ./gradlew build
    ```

3. Find output JAR in:

    ```
    build/libs/
    ```

---

## 8. Common Errors and How to Fix Them

| Error Message                          | Cause                                     | Fix                                                  |
|--------------------------------------|-------------------------------------------|------------------------------------------------------|
| `no main manifest attribute`         | JAR missing `Main-Class` in manifest      | Add `Main-Class` attribute in manifest or build config|
| `Could not find method platform()`   | Old Gradle version used                     | Update Gradle or use Gradle Wrapper                  |
| `Permission denied: ./gradlew`       | Gradle Wrapper script not executable       | Run `chmod +x gradlew`                                |

---

## 9. Workflow Diagram: Java Build & Run Process

```plaintext
[Write Java Code (.java)]
          │
          ▼
[Compile with javac]
          │
          ▼
[Bytecode (.class files)]
          │
          ├───────────────┐
          │               │
          ▼               ▼
[Run with JVM]      [Package into JAR]
          │               │
          ▼               ▼
   JVM interprets     [Add MANIFEST.MF]
   bytecode & JIT         │
          │               ▼
          ▼            Executable JAR
   Runs program         (.jar file)
```

---

## 10. Summary Table: Tools & Files

| Tool/File          | Purpose                                      | Location/Usage                                   |
|--------------------|----------------------------------------------|-------------------------------------------------|
| `javac`            | Java compiler                                | Compile `.java` to `.class`                      |
| `java`             | JVM launcher                                 | Run `.class` or `.jar`                           |
| `.class`           | Bytecode file                                | Output of compilation                            |
| `.jar`             | Java archive (packed classes & metadata)     | Distribution or executable                        |
| `META-INF/MANIFEST.MF` | Metadata file inside `.jar`                   | Specifies main class, version, etc.               |
| `gradle`            | Build tool                                   | Compile, test, package Java projects             |
| `gradlew`           | Gradle wrapper script                        | Run Gradle build with project-specific version   |
| IntelliJ Artifacts  | Build config to package JARs in IDE          | Manages output directory and manifest settings   |

---

# Additional Resources & Practice Ideas

- Experiment running Java `.class` files on different OS with JVM installed.
- Write multi-class Java apps, package into JAR with manifest.
- Use IntelliJ to explore compilation output and build artifacts.
- Create a Gradle project, add dependencies, use `gradlew` for builds.
- Debug common build errors by reading Gradle/Maven logs.

---
